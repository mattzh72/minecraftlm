"""
Terrain generator for procedural Minecraft landscapes.

Generates plains biome terrain with grass, dirt, and stone layers.
Integrates with the existing SDK scene graph as an Object3D subclass.

Example:
    terrain = create_terrain(128, 128, seed=42)
    terrain.generate()

    scene = Scene()
    scene.add(terrain)
    result = scene.to_structure()
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

import numpy as np

from app.agent.minecraft.sdk import Block, BlockCatalog, Object3D, Vector3
from app.agent.minecraft.terrain.heightmap import HeightMap, HeightMapConfig
from app.agent.minecraft.terrain.noise import NoiseConfig


@dataclass
class TerrainConfig:
    """Configuration for terrain generation.

    Attributes:
        width: Width in blocks (X axis).
        depth: Depth in blocks (Z axis).
        base_height: Base terrain height.
        height_range: Maximum height deviation from base.
        seed: Random seed for deterministic generation.
        generate_decorations: Whether to add trees/flowers.
        noise_config: Configuration for terrain noise.
    """

    width: int = 256
    depth: int = 256
    base_height: int = 64
    height_range: int = 32
    seed: int = 42
    generate_decorations: bool = True
    noise_config: NoiseConfig = field(default_factory=NoiseConfig)


# Plains biome layer definitions
PLAINS_LAYERS = [
    # (block_id, depth, properties)
    ("minecraft:grass_block", 1, {"snowy": "false"}),
    ("minecraft:dirt", 3, {}),
    ("minecraft:stone", 999, {}),  # Fill to bottom
]


class Terrain(Object3D):
    """Procedural terrain generator.

    Extends Object3D to integrate with the existing scene graph.
    Generates plains biome terrain with optimized block merging.

    Example:
        config = TerrainConfig(width=128, depth=128)
        terrain = Terrain(config)
        terrain.generate()

        scene = Scene()
        scene.add(terrain)

        # Query terrain
        height = terrain.get_height_at(64, 64)
    """

    def __init__(
        self,
        config: TerrainConfig,
        catalog: Optional[BlockCatalog] = None,
    ) -> None:
        """Initialize terrain generator.

        Args:
            config: Terrain configuration.
            catalog: Block catalog for validation (created if not provided).
        """
        super().__init__()
        self.config = config
        self.catalog = catalog or BlockCatalog()

        # Initialize heightmap config from terrain config
        heightmap_config = HeightMapConfig(
            width=config.width,
            depth=config.depth,
            base_height=config.base_height,
            height_range=config.height_range,
            noise_config=config.noise_config,
        )
        self.heightmap = HeightMap(heightmap_config)
        self._generated = False

    def generate(self) -> "Terrain":
        """Generate complete terrain.

        Creates heightmap, generates terrain blocks, and optionally adds decorations.
        Blocks are optimized by merging contiguous regions.

        Returns:
            Self for chaining.
        """
        # Generate heightmap (if not already generated by flatten_for_structure)
        if not self.heightmap._generated:
            self.heightmap.generate()

        # Generate terrain blocks with optimization
        self._generate_terrain_blocks()

        # Add decorations if enabled
        if self.config.generate_decorations:
            self._add_decorations()

        self._generated = True
        return self

    def _generate_terrain_blocks(self) -> None:
        """Generate optimized terrain blocks.

        Uses run-length encoding to merge contiguous columns with same height
        into larger blocks, significantly reducing block count.
        """
        heights = self.heightmap.heights
        min_height = self.heightmap.min_height()

        # Process each layer type separately for better merging
        for block_id, layer_depth, properties in PLAINS_LAYERS:
            self._generate_layer_blocks(
                block_id, layer_depth, properties, heights, min_height
            )

    def _generate_layer_blocks(
        self,
        block_id: str,
        layer_depth: int,
        properties: Dict[str, str],
        heights: np.ndarray,
        min_height: int,
    ) -> None:
        """Generate blocks for a single terrain layer with run-length merging.

        Scans the terrain row by row, merging adjacent columns with the
        same layer bounds into single wider blocks.
        """
        width = self.config.width
        depth = self.config.depth

        # Track which columns have been processed
        processed = np.zeros((depth, width), dtype=bool)

        for z in range(depth):
            x = 0
            while x < width:
                if processed[z, x]:
                    x += 1
                    continue

                # Calculate layer bounds for this column
                surface_height = heights[z, x]
                layer_top, layer_bottom = self._get_layer_bounds(
                    surface_height, block_id, layer_depth, min_height
                )

                if layer_top <= layer_bottom:
                    x += 1
                    continue

                # Find run of columns with same layer bounds
                run_length = 1
                while x + run_length < width:
                    next_surface = heights[z, x + run_length]
                    next_top, next_bottom = self._get_layer_bounds(
                        next_surface, block_id, layer_depth, min_height
                    )
                    if next_top == layer_top and next_bottom == layer_bottom:
                        run_length += 1
                    else:
                        break

                # Try to extend in Z direction for 2D merging
                run_depth = 1
                can_extend = True
                while can_extend and z + run_depth < depth:
                    # Check if entire row matches
                    for dx in range(run_length):
                        if processed[z + run_depth, x + dx]:
                            can_extend = False
                            break
                        row_surface = heights[z + run_depth, x + dx]
                        row_top, row_bottom = self._get_layer_bounds(
                            row_surface, block_id, layer_depth, min_height
                        )
                        if row_top != layer_top or row_bottom != layer_bottom:
                            can_extend = False
                            break
                    if can_extend:
                        run_depth += 1

                # Create merged block
                layer_height = layer_top - layer_bottom
                block = Block(
                    block_id,
                    size=(run_length, layer_height, run_depth),
                    properties=properties if properties else None,
                    fill=True,
                    catalog=self.catalog,
                )
                block.position.set(x, layer_bottom, z)
                self.children.append(block)

                # Mark columns as processed
                for dz in range(run_depth):
                    for dx in range(run_length):
                        processed[z + dz, x + dx] = True

                x += run_length

    def _get_layer_bounds(
        self,
        surface_height: int,
        block_id: str,
        layer_depth: int,
        min_height: int,
    ) -> Tuple[int, int]:
        """Calculate top and bottom Y for a layer at given surface height.

        Returns:
            Tuple of (layer_top, layer_bottom) Y coordinates.
        """
        if block_id == "minecraft:grass_block":
            # Grass is always the top block
            return (surface_height, surface_height - 1)
        elif block_id == "minecraft:dirt":
            # Dirt is below grass
            dirt_top = surface_height - 1
            dirt_bottom = surface_height - 1 - layer_depth
            return (dirt_top, max(dirt_bottom, min_height))
        elif block_id == "minecraft:stone":
            # Stone fills from dirt bottom to min_height
            stone_top = surface_height - 4  # Below grass(1) + dirt(3)
            stone_bottom = min_height
            if stone_top <= stone_bottom:
                return (0, 0)  # No stone needed
            return (stone_top, stone_bottom)
        return (0, 0)

    def _add_decorations(self) -> None:
        """Add trees and vegetation to terrain.

        Imports decoration generators and places them based on noise.
        """
        # Import here to avoid circular dependency
        from app.agent.minecraft.terrain.decorations import (
            generate_oak_tree,
            generate_flowers,
            generate_tall_grass,
        )

        # Use separate noise for decoration placement
        from app.agent.minecraft.terrain.noise import PerlinNoise

        decor_noise = PerlinNoise(seed=self.config.seed + 1000)
        flower_noise = PerlinNoise(seed=self.config.seed + 2000)

        # Sparse tree placement
        tree_spacing = 12  # Minimum spacing between trees
        for z in range(0, self.config.depth - 5, tree_spacing):
            for x in range(0, self.config.width - 5, tree_spacing):
                # Use noise to vary placement within grid cell
                noise_val = decor_noise.noise2d(x / 20.0, z / 20.0)
                if noise_val > 0.3:  # ~35% of grid cells get trees
                    # Offset within cell based on noise
                    offset_x = int((noise_val + 1) * 3) % tree_spacing
                    offset_z = int((noise_val * 2 + 1) * 3) % tree_spacing
                    tree_x = x + offset_x
                    tree_z = z + offset_z

                    if tree_x < self.config.width - 3 and tree_z < self.config.depth - 3:
                        height = self.heightmap.get(tree_x, tree_z)
                        tree = generate_oak_tree(
                            tree_x, height, tree_z,
                            catalog=self.catalog,
                            seed=self.config.seed + tree_x * 1000 + tree_z,
                        )
                        self.children.append(tree)

        # Scattered flowers and grass
        for z in range(self.config.depth):
            for x in range(self.config.width):
                noise_val = flower_noise.noise2d(x / 5.0, z / 5.0)

                if noise_val > 0.6:  # ~20% coverage for flowers
                    height = self.heightmap.get(x, z)
                    flower = generate_flowers(x, height, z, catalog=self.catalog)
                    self.children.append(flower)
                elif noise_val > 0.3 and noise_val <= 0.4:  # ~10% for tall grass
                    height = self.heightmap.get(x, z)
                    grass = generate_tall_grass(x, height, z, catalog=self.catalog)
                    self.children.append(grass)

    def get_height_at(self, x: int, z: int) -> int:
        """Get terrain surface height at world position.

        Accounts for terrain position offset.

        Args:
            x: World X coordinate.
            z: World Z coordinate.

        Returns:
            Surface height at position.
        """
        # Adjust for terrain position
        local_x = int(x - self.position.x)
        local_z = int(z - self.position.z)
        return self.heightmap.get(local_x, local_z)

    def flatten_for_structure(
        self,
        x: int,
        z: int,
        width: int,
        depth: int,
        target_height: Optional[int] = None,
        falloff: int = 4,
    ) -> "Terrain":
        """Flatten terrain area for structure placement.

        Can be called before or after generate(). If called before,
        the heightmap will be generated first, then flattened.

        Args:
            x, z: Corner position in local terrain coordinates.
            width, depth: Area dimensions.
            target_height: Height to flatten to (area average if None).
            falloff: Blending distance at edges.

        Returns:
            Self for chaining.
        """
        # Ensure heightmap is generated before flattening
        if not self.heightmap._generated:
            self.heightmap.generate()

        self.heightmap.flatten_area(x, z, width, depth, target_height, falloff)
        return self


def create_terrain(
    width: int = 128,
    depth: int = 128,
    seed: int = 42,
    base_height: int = 64,
    height_range: int = 32,
    generate_decorations: bool = True,
    catalog: Optional[BlockCatalog] = None,
) -> Terrain:
    """Create a plains terrain with sensible defaults.

    Convenience factory for quick terrain generation.

    Args:
        width: Width in blocks (X axis).
        depth: Depth in blocks (Z axis).
        seed: Random seed.
        base_height: Base terrain height.
        height_range: Height variation range.
        generate_decorations: Add trees and flowers.
        catalog: Block catalog (created if not provided).

    Returns:
        Terrain instance (call .generate() to populate).

    Example:
        terrain = create_terrain(128, 128, seed=42)
        terrain.generate()

        scene = Scene()
        scene.add(terrain)
    """
    config = TerrainConfig(
        width=width,
        depth=depth,
        seed=seed,
        base_height=base_height,
        height_range=height_range,
        generate_decorations=generate_decorations,
    )
    return Terrain(config, catalog=catalog)
